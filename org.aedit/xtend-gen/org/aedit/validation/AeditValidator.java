/**
 * generated by Xtext 2.12.0
 */
package org.aedit.validation;

import HelperClass.HelperClass;
import avroclipse.avroIDL.AvroIDLFile;
import avroclipse.avroIDL.Field;
import avroclipse.avroIDL.FieldType;
import avroclipse.avroIDL.PrimativeTypeLink;
import avroclipse.avroIDL.RecordType;
import avroclipse.avroIDL.TypeDef;
import avroclipse.avroIDL.Value;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import org.aedit.aedit.AddEnum;
import org.aedit.aedit.AddEnumeration;
import org.aedit.aedit.AeditPackage;
import org.aedit.aedit.ChangeDefValue;
import org.aedit.aedit.ChangeEnum;
import org.aedit.aedit.ChangeSchema;
import org.aedit.aedit.ChangeType;
import org.aedit.aedit.FloatValue;
import org.aedit.aedit.GenericRule;
import org.aedit.aedit.IntValue;
import org.aedit.aedit.Model;
import org.aedit.aedit.PrimitiveTypeField;
import org.aedit.aedit.RemoveEnum;
import org.aedit.aedit.RemoveSchema;
import org.aedit.aedit.RemoveVariable;
import org.aedit.aedit.RenameEnum;
import org.aedit.aedit.RenameSchema;
import org.aedit.aedit.RenameVariable;
import org.aedit.aedit.RuleDeclaration;
import org.aedit.aedit.RuleMap;
import org.aedit.aedit.StringValue;
import org.aedit.validation.AbstractAeditValidator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class AeditValidator extends AbstractAeditValidator {
  private static Map<String, AvroIDLFile> protocols = new HashMap<String, AvroIDLFile>();
  
  private List<String> removedVariables = new ArrayList<String>();
  
  private List<String> newVariables = new ArrayList<String>();
  
  private List<String> existingVariables = new ArrayList<String>();
  
  protected static final String ISSUE_CODE_PREFIX = "org.aedit.";
  
  public static final String REMOVE_SCHEMA = (AeditValidator.ISSUE_CODE_PREFIX + "RemoveSchema");
  
  public static final String REMOVE_VARIABLE = (AeditValidator.ISSUE_CODE_PREFIX + "RemoveVariable");
  
  public static final String REMOVE_ENUM_CONST = (AeditValidator.ISSUE_CODE_PREFIX + "RemoveEnumConst");
  
  public static final String DUPLICATE_FIELD = (AeditValidator.ISSUE_CODE_PREFIX + "DuplicateField");
  
  private String currentSchema;
  
  private String currentProtocol;
  
  @Check
  public void checkModel(final Model model) {
    AeditValidator.protocols.clear();
    boolean _isEmpty = AeditValidator.protocols.isEmpty();
    if (_isEmpty) {
      AeditValidator.protocols = HelperClass.getAvroFiles(model.eResource());
      final BiConsumer<String, AvroIDLFile> _function = (String p1, AvroIDLFile p2) -> {
        this.existingVariables.addAll(HelperClass.getSchemasAndFields(p2));
      };
      AeditValidator.protocols.forEach(_function);
    }
  }
  
  @Check
  public void checkRuleDeclaration(final RuleDeclaration ruleDeclaration) {
    this.removedVariables.clear();
    this.newVariables.clear();
  }
  
  @Check
  public void checkChangeSchema(final ChangeSchema changeSchema) {
    this.currentSchema = changeSchema.getSchema().getName();
    EObject _eContainer = changeSchema.getSchema().eContainer();
    TypeDef schemaContainer = ((TypeDef) _eContainer);
    EObject _eContainer_1 = schemaContainer.eContainer();
    this.currentProtocol = ((AvroIDLFile) _eContainer_1).getName();
    String fullName = ((this.currentProtocol + ".") + this.currentSchema);
    boolean _contains = this.removedVariables.contains(fullName);
    if (_contains) {
      this.error("Schema does not exist!", AeditPackage.Literals.CHANGE_SCHEMA__SCHEMA, 
        AeditValidator.REMOVE_SCHEMA, fullName);
    }
  }
  
  @Check
  public void checkChangeEnum(final ChangeEnum changeEnum) {
    this.currentSchema = changeEnum.getSchema().getName();
    EObject _eContainer = changeEnum.getSchema().eContainer();
    TypeDef schemaContainer = ((TypeDef) _eContainer);
    EObject _eContainer_1 = schemaContainer.eContainer();
    this.currentProtocol = ((AvroIDLFile) _eContainer_1).getName();
    String fullName = ((this.currentProtocol + ".") + this.currentSchema);
    boolean _contains = this.removedVariables.contains(fullName);
    if (_contains) {
      this.error("Schema does not exist!", AeditPackage.Literals.CHANGE_ENUM__SCHEMA, 
        AeditValidator.REMOVE_SCHEMA, fullName);
    }
  }
  
  @Check
  public Boolean checkRemoveVariable(final RemoveVariable removeVariable) {
    boolean _xblockexpression = false;
    {
      String _name = removeVariable.getVariable().getName();
      String fullName = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _name);
      boolean _xifexpression = false;
      boolean _contains = this.removedVariables.contains(fullName);
      if (_contains) {
        this.error("Variable has been deleted!", AeditPackage.Literals.REMOVE_VARIABLE__VARIABLE, AeditValidator.REMOVE_VARIABLE, fullName);
      } else {
        _xifexpression = this.removedVariables.add(fullName);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  @Check
  public Boolean checkRenameVariable(final RenameVariable renameVariable) {
    boolean _xblockexpression = false;
    {
      String _name = renameVariable.getVariable().getName();
      String oldVar = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _name);
      String _newVarName = renameVariable.getNewVarName();
      String newVar = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _newVarName);
      boolean _contains = this.removedVariables.contains(oldVar);
      if (_contains) {
        this.error("Variable has been deleted!", AeditPackage.Literals.RENAME_VARIABLE__VARIABLE, AeditValidator.REMOVE_VARIABLE, oldVar);
      }
      boolean _xifexpression = false;
      boolean _isUnique = this.isUnique(newVar);
      if (_isUnique) {
        this.error("Variable with that name already exists!", AeditPackage.Literals.RENAME_VARIABLE__NEW_VAR_NAME);
      } else {
        _xifexpression = this.removedVariables.add(oldVar);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  @Check
  public Boolean checkRemoveSchema(final RemoveSchema removeSchema) {
    boolean _xblockexpression = false;
    {
      final String schemaName = removeSchema.getSchema().getName();
      EObject _eContainer = removeSchema.getSchema().eContainer();
      TypeDef schemaContainer = ((TypeDef) _eContainer);
      EObject _eContainer_1 = schemaContainer.eContainer();
      final String protocolName = ((AvroIDLFile) _eContainer_1).getName();
      String fullName = ((protocolName + ".") + schemaName);
      boolean _xifexpression = false;
      boolean _contains = this.removedVariables.contains(fullName);
      if (_contains) {
        this.error("Schema does not exist!", AeditPackage.Literals.REMOVE_SCHEMA__SCHEMA, 
          AeditValidator.REMOVE_SCHEMA, fullName);
      } else {
        _xifexpression = this.removedVariables.add(fullName);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  @Check
  public Boolean checkRenameSchema(final RenameSchema RenameSchema) {
    boolean _xblockexpression = false;
    {
      final String schemaName = RenameSchema.getSchema().getName();
      EObject _eContainer = RenameSchema.getSchema().eContainer();
      TypeDef schemaContainer = ((TypeDef) _eContainer);
      EObject _eContainer_1 = schemaContainer.eContainer();
      final String protocolName = ((AvroIDLFile) _eContainer_1).getName();
      String fullName = ((protocolName + ".") + schemaName);
      boolean _xifexpression = false;
      boolean _contains = this.removedVariables.contains(fullName);
      if (_contains) {
        this.error("Schema does not exist!", AeditPackage.Literals.RENAME_SCHEMA__SCHEMA, 
          AeditValidator.REMOVE_SCHEMA, fullName);
      } else {
        _xifexpression = this.removedVariables.add(fullName);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  @Check
  public Boolean checkRemoveEnumConstant(final RemoveEnum removeEnum) {
    boolean _xblockexpression = false;
    {
      String _varName = removeEnum.getVarName();
      String fullName = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _varName);
      boolean _xifexpression = false;
      boolean _contains = this.removedVariables.contains(fullName);
      if (_contains) {
        this.error("Constant does not exist!", AeditPackage.Literals.REMOVE_ENUM__VAR_NAME, AeditValidator.REMOVE_ENUM_CONST, fullName);
      } else {
        boolean _xifexpression_1 = false;
        boolean _contains_1 = this.existingVariables.contains(fullName);
        boolean _not = (!_contains_1);
        if (_not) {
          this.error("Constant does not exist!", AeditPackage.Literals.REMOVE_ENUM__VAR_NAME, AeditValidator.REMOVE_ENUM_CONST, fullName);
        } else {
          _xifexpression_1 = this.removedVariables.add(fullName);
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  @Check
  public Boolean checkRenameEnumConstant(final RenameEnum renameEnum) {
    boolean _xblockexpression = false;
    {
      String _oldName = renameEnum.getOldName();
      String oldEnum = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _oldName);
      String _newEnumName = renameEnum.getNewEnumName();
      String newEnum = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _newEnumName);
      boolean _contains = this.removedVariables.contains(oldEnum);
      if (_contains) {
        this.error("Variable has been deleted!", AeditPackage.Literals.RENAME_ENUM__OLD_NAME);
      } else {
        boolean _contains_1 = this.existingVariables.contains(oldEnum);
        boolean _not = (!_contains_1);
        if (_not) {
          this.error("Variable has been deleted!", AeditPackage.Literals.RENAME_ENUM__OLD_NAME);
        }
      }
      boolean _xifexpression = false;
      boolean _isUnique = this.isUnique(newEnum);
      if (_isUnique) {
        this.error("Variable with that name already exists!", AeditPackage.Literals.RENAME_ENUM__NEW_ENUM_NAME);
      } else {
        _xifexpression = this.removedVariables.add(oldEnum);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  @Check
  public void checkChangeType(final ChangeType changeType) {
    Value variable = this.getVariable(this.currentProtocol, this.currentSchema, changeType.getField().getName()).getDefault();
    String _name = changeType.getField().getName();
    String fullName = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _name);
    boolean _contains = this.removedVariables.contains(fullName);
    if (_contains) {
      this.error("Variable has been deleted!", AeditPackage.Literals.CHANGE_TYPE__FIELD, AeditValidator.REMOVE_VARIABLE, fullName);
    } else {
      if ((variable != null)) {
        FieldType varType = changeType.getField().getType();
        if ((varType instanceof PrimativeTypeLink)) {
          boolean _equals = ((PrimativeTypeLink)varType).getTarget().equals("int");
          if (_equals) {
            String _newType = changeType.getNewType();
            if (_newType != null) {
              switch (_newType) {
                case "string":
                  this.error("Cannot convert from int to string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                  break;
                case "int":
                  this.error("Variable is already of type int!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                  break;
              }
            }
          } else {
            boolean _equals_1 = ((PrimativeTypeLink)varType).getTarget().equals("long");
            if (_equals_1) {
              String _newType_1 = changeType.getNewType();
              if (_newType_1 != null) {
                switch (_newType_1) {
                  case "string":
                    this.error("Cannot convert from long to string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                    break;
                  case "int":
                    this.error("Cannot convert from long to int!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                    break;
                  case "double":
                    this.error("Cannot convert from long to double!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                    break;
                  case "long":
                    this.error("Variable is already of type long!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                    break;
                }
              }
            } else {
              boolean _equals_2 = ((PrimativeTypeLink)varType).getTarget().equals("double");
              if (_equals_2) {
                String _newType_2 = changeType.getNewType();
                if (_newType_2 != null) {
                  switch (_newType_2) {
                    case "string":
                      this.error("Cannot convert from double to string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                      break;
                    case "int":
                      this.error("Cannot convert from double to int!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                      break;
                    case "double":
                      this.error("Variable is already of type double!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                      break;
                  }
                }
              } else {
                boolean _equals_3 = ((PrimativeTypeLink)varType).getTarget().equals("string");
                if (_equals_3) {
                  String _newType_3 = changeType.getNewType();
                  if (_newType_3 != null) {
                    switch (_newType_3) {
                      case "string":
                        this.error("Variable is already of type string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                        break;
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        FieldType varType_1 = changeType.getField().getType();
        if ((varType_1 instanceof PrimativeTypeLink)) {
          boolean _equals_4 = ((PrimativeTypeLink)varType_1).getTarget().equals("int");
          if (_equals_4) {
            String _newType_4 = changeType.getNewType();
            if (_newType_4 != null) {
              switch (_newType_4) {
                case "int":
                  this.error("Variable is already of type int!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                  break;
              }
            }
          } else {
            boolean _equals_5 = ((PrimativeTypeLink)varType_1).getTarget().equals("long");
            if (_equals_5) {
              String _newType_5 = changeType.getNewType();
              if (_newType_5 != null) {
                switch (_newType_5) {
                  case "long":
                    this.error("Variable is already of type long!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                    break;
                }
              }
            } else {
              boolean _equals_6 = ((PrimativeTypeLink)varType_1).getTarget().equals("double");
              if (_equals_6) {
                String _newType_6 = changeType.getNewType();
                if (_newType_6 != null) {
                  switch (_newType_6) {
                    case "double":
                      this.error("Variable is already of type double!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                      break;
                  }
                }
              } else {
                boolean _equals_7 = ((PrimativeTypeLink)varType_1).getTarget().equals("string");
                if (_equals_7) {
                  String _newType_7 = changeType.getNewType();
                  if (_newType_7 != null) {
                    switch (_newType_7) {
                      case "string":
                        this.error("Variable is already of type string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE);
                        break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkChangeDefValue(final ChangeDefValue changeDefValue) {
    String _name = changeDefValue.getField().getName();
    String fullName = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _name);
    boolean _contains = this.removedVariables.contains(fullName);
    boolean _not = (!_contains);
    if (_not) {
      FieldType varType = changeDefValue.getField().getType();
      if ((varType instanceof PrimativeTypeLink)) {
        boolean _equals = ((PrimativeTypeLink)varType).getTarget().equals("int");
        if (_equals) {
          org.aedit.aedit.Value _newVal = changeDefValue.getNewVal();
          boolean _matched = false;
          org.aedit.aedit.Value _newVal_1 = changeDefValue.getNewVal();
          if ((_newVal_1 instanceof StringValue)) {
            _matched=true;
            this.error("Cannot assign string to int!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
          }
        } else {
          boolean _equals_1 = ((PrimativeTypeLink)varType).getTarget().equals("long");
          if (_equals_1) {
            org.aedit.aedit.Value _newVal_2 = changeDefValue.getNewVal();
            boolean _matched_1 = false;
            org.aedit.aedit.Value _newVal_3 = changeDefValue.getNewVal();
            if ((_newVal_3 instanceof StringValue)) {
              _matched_1=true;
              this.error("Cannot assign string to long!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
            }
            if (!_matched_1) {
              org.aedit.aedit.Value _newVal_4 = changeDefValue.getNewVal();
              if ((_newVal_4 instanceof FloatValue)) {
                _matched_1=true;
                this.error("Cannot assign float to long!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
              }
            }
          } else {
            boolean _equals_2 = ((PrimativeTypeLink)varType).getTarget().equals("double");
            if (_equals_2) {
              org.aedit.aedit.Value _newVal_5 = changeDefValue.getNewVal();
              boolean _matched_2 = false;
              org.aedit.aedit.Value _newVal_6 = changeDefValue.getNewVal();
              if ((_newVal_6 instanceof StringValue)) {
                _matched_2=true;
                this.error("Cannot assign string to double!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
              }
              if (!_matched_2) {
                org.aedit.aedit.Value _newVal_7 = changeDefValue.getNewVal();
                if ((_newVal_7 instanceof IntValue)) {
                  _matched_2=true;
                  this.error("Cannot assign int to double!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
                }
              }
            } else {
              boolean _equals_3 = ((PrimativeTypeLink)varType).getTarget().equals("string");
              if (_equals_3) {
                org.aedit.aedit.Value _newVal_8 = changeDefValue.getNewVal();
                boolean _matched_3 = false;
                org.aedit.aedit.Value _newVal_9 = changeDefValue.getNewVal();
                if ((_newVal_9 instanceof IntValue)) {
                  _matched_3=true;
                  this.error("Cannot assign integer to string!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
                }
                if (!_matched_3) {
                  org.aedit.aedit.Value _newVal_10 = changeDefValue.getNewVal();
                  if ((_newVal_10 instanceof FloatValue)) {
                    _matched_3=true;
                    this.error("Cannot assign float to string!", AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL);
                  }
                }
              }
            }
          }
        }
      }
    } else {
      this.error("Variable has been deleted!", AeditPackage.Literals.CHANGE_DEF_VALUE__FIELD, AeditValidator.REMOVE_VARIABLE, fullName);
    }
  }
  
  @Check
  public void checkAddEnumeration(final AddEnumeration addEnumeration) {
    String _name = addEnumeration.getNamespace().getName();
    String _plus = (_name + ".");
    String _enumName = addEnumeration.getEnumName();
    String enumName = (_plus + _enumName);
    boolean _contains = this.existingVariables.contains(enumName);
    if (_contains) {
      this.error("Enumeration with this name already exists in this namespace!", 
        AeditPackage.Literals.ADD_ENUMERATION__ENUM_NAME);
    } else {
      this.newVariables.add(enumName);
      EList<String> _symbols = addEnumeration.getSymbols();
      for (final String symbol : _symbols) {
        {
          String symbolName = (enumName + symbol);
          boolean _contains_1 = this.newVariables.contains(symbol);
          if (_contains_1) {
            this.error("Enum with this name already exists!", AeditPackage.Literals.ADD_ENUMERATION__SYMBOLS, 
              addEnumeration.getSymbols().indexOf(symbol));
          } else {
            this.newVariables.add(symbolName);
          }
        }
      }
    }
  }
  
  @Check
  public void checkAddEnumConstant(final AddEnum addEnum) {
    String _varName = addEnum.getVarName();
    String fullName = ((((this.currentProtocol + ".") + this.currentSchema) + ".") + _varName);
    boolean _contains = this.existingVariables.contains(fullName);
    if (_contains) {
      this.error("Field with this name already exists!", AeditPackage.Literals.ADD_ENUM__VAR_NAME, AeditValidator.DUPLICATE_FIELD, fullName);
    }
  }
  
  @Check
  public void checkField(final PrimitiveTypeField field) {
    boolean _equals = field.getType().equals("long");
    if (_equals) {
      org.aedit.aedit.Value _value = field.getValue();
      if ((((Object) _value) instanceof String)) {
        this.error("Cannot assign string value to long!", AeditPackage.Literals.PRIMITIVE_TYPE_FIELD__VALUE);
      }
    } else {
      boolean _equals_1 = field.getType().equals("double");
      if (_equals_1) {
        org.aedit.aedit.Value _value_1 = field.getValue();
        if ((((Object) _value_1) instanceof String)) {
          this.error("Cannot assign string value to double!", AeditPackage.Literals.PRIMITIVE_TYPE_FIELD__VALUE);
        }
      } else {
        boolean _equals_2 = field.getType().equals("int");
        if (_equals_2) {
          org.aedit.aedit.Value _value_2 = field.getValue();
          if ((((Object) _value_2) instanceof String)) {
            this.error("Cannot assign string value to int!", AeditPackage.Literals.PRIMITIVE_TYPE_FIELD__VALUE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkForConflicts(final RuleMap rm) {
    EList<RuleDeclaration> _rules = rm.getRules();
    for (final RuleDeclaration ruleDecl : _rules) {
      EList<RuleDeclaration> _rules_1 = rm.getRules();
      for (final RuleDeclaration otherRuleDecl : _rules_1) {
        if ((ruleDecl != otherRuleDecl)) {
          this.getDeleteConflicts(ruleDecl, otherRuleDecl, rm.getRules().indexOf(ruleDecl));
          this.getSchemaEditConflicts(ruleDecl, otherRuleDecl, rm.getRules().indexOf(ruleDecl));
          this.getEnumEditConflicts(ruleDecl, otherRuleDecl, rm.getRules().indexOf(ruleDecl));
        }
      }
    }
  }
  
  public void getDeleteConflicts(final RuleDeclaration a, final RuleDeclaration b, final int index) {
    final Iterable<RemoveSchema> aRules = Iterables.<RemoveSchema>filter(IteratorExtensions.<EObject>toList(a.eAllContents()), RemoveSchema.class);
    final Iterable<RemoveSchema> bRules = Iterables.<RemoveSchema>filter(IteratorExtensions.<EObject>toList(b.eAllContents()), RemoveSchema.class);
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(aRules, Object.class)).length); i++) {
      {
        final String aSchemaName = (((RemoveSchema[])Conversions.unwrapArray(aRules, RemoveSchema.class))[i]).getSchema().getName();
        EObject _eContainer = (((RemoveSchema[])Conversions.unwrapArray(aRules, RemoveSchema.class))[i]).getSchema().eContainer();
        final TypeDef aSchemaContainer = ((TypeDef) _eContainer);
        EObject _eContainer_1 = aSchemaContainer.eContainer();
        final String aProtocolName = ((AvroIDLFile) _eContainer_1).getName();
        for (int j = 0; (j < ((Object[])Conversions.unwrapArray(bRules, Object.class)).length); j++) {
          {
            final String bSchemaName = (((RemoveSchema[])Conversions.unwrapArray(bRules, RemoveSchema.class))[j]).getSchema().getName();
            EObject _eContainer_2 = (((RemoveSchema[])Conversions.unwrapArray(bRules, RemoveSchema.class))[j]).getSchema().eContainer();
            final TypeDef bSchemaContainer = ((TypeDef) _eContainer_2);
            EObject _eContainer_3 = bSchemaContainer.eContainer();
            final String bProtocolName = ((AvroIDLFile) _eContainer_3).getName();
            if ((aSchemaName.equals(bSchemaName) && aProtocolName.equals(bProtocolName))) {
              this.error(
                String.format("CONCURENT MODIFICATION ERROR: %s is deleted in %s and %s", 
                  ((aProtocolName + ".") + aSchemaName), a.getName(), b.getName()), 
                AeditPackage.Literals.RULE_MAP__RULES, index);
            }
          }
        }
      }
    }
  }
  
  public void getSchemaEditConflicts(final RuleDeclaration a, final RuleDeclaration b, final int index) {
    final Iterable<ChangeSchema> aRules = Iterables.<ChangeSchema>filter(IteratorExtensions.<EObject>toList(a.eAllContents()), ChangeSchema.class);
    final Iterable<ChangeSchema> bRules = Iterables.<ChangeSchema>filter(IteratorExtensions.<EObject>toList(b.eAllContents()), ChangeSchema.class);
    this.currentRuleIndex = index;
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(aRules, Object.class)).length); i++) {
      {
        final String aSchemaName = (((ChangeSchema[])Conversions.unwrapArray(aRules, ChangeSchema.class))[i]).getSchema().getName();
        EObject _eContainer = (((ChangeSchema[])Conversions.unwrapArray(aRules, ChangeSchema.class))[i]).getSchema().eContainer();
        final TypeDef aSchemaContainer = ((TypeDef) _eContainer);
        EObject _eContainer_1 = aSchemaContainer.eContainer();
        final String aProtocolName = ((AvroIDLFile) _eContainer_1).getName();
        for (int j = 0; (j < ((Object[])Conversions.unwrapArray(bRules, Object.class)).length); j++) {
          {
            final String bSchemaName = (((ChangeSchema[])Conversions.unwrapArray(bRules, ChangeSchema.class))[j]).getSchema().getName();
            EObject _eContainer_2 = (((ChangeSchema[])Conversions.unwrapArray(bRules, ChangeSchema.class))[j]).getSchema().eContainer();
            final TypeDef bSchemaContainer = ((TypeDef) _eContainer_2);
            EObject _eContainer_3 = bSchemaContainer.eContainer();
            final String bProtocolName = ((AvroIDLFile) _eContainer_3).getName();
            if ((aSchemaName.equals(bSchemaName) && aProtocolName.equals(bProtocolName))) {
              this.warning(
                String.format("CONCURENT MODIFICATION ERROR: %s is edited in %s and %s", 
                  ((aProtocolName + ".") + aSchemaName), a.getName(), b.getName()), 
                AeditPackage.Literals.RULE_MAP__RULES, index);
              this.getVarDeleteConflicts(((GenericRule[])Conversions.unwrapArray(aRules, GenericRule.class))[i], ((GenericRule[])Conversions.unwrapArray(bRules, GenericRule.class))[j], a.getName(), b.getName());
              this.getVarRenameConflicts(((GenericRule[])Conversions.unwrapArray(aRules, GenericRule.class))[i], ((GenericRule[])Conversions.unwrapArray(bRules, GenericRule.class))[j], a.getName(), b.getName());
              this.getVarSetTypeConflicts(((GenericRule[])Conversions.unwrapArray(aRules, GenericRule.class))[i], ((GenericRule[])Conversions.unwrapArray(bRules, GenericRule.class))[j], a.getName(), b.getName());
              this.getVarChangeDataConflicts(((GenericRule[])Conversions.unwrapArray(aRules, GenericRule.class))[i], ((GenericRule[])Conversions.unwrapArray(bRules, GenericRule.class))[j], a.getName(), b.getName());
            }
          }
        }
      }
    }
  }
  
  private int currentRuleIndex;
  
  public void getEnumEditConflicts(final RuleDeclaration a, final RuleDeclaration b, final int index) {
    final Iterable<ChangeEnum> aRules = Iterables.<ChangeEnum>filter(IteratorExtensions.<EObject>toList(a.eAllContents()), ChangeEnum.class);
    final Iterable<ChangeEnum> bRules = Iterables.<ChangeEnum>filter(IteratorExtensions.<EObject>toList(b.eAllContents()), ChangeEnum.class);
    this.currentRuleIndex = index;
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(aRules, Object.class)).length); i++) {
      {
        final String aSchemaName = (((ChangeEnum[])Conversions.unwrapArray(aRules, ChangeEnum.class))[i]).getSchema().getName();
        EObject _eContainer = (((ChangeEnum[])Conversions.unwrapArray(aRules, ChangeEnum.class))[i]).getSchema().eContainer();
        final TypeDef aSchemaContainer = ((TypeDef) _eContainer);
        EObject _eContainer_1 = aSchemaContainer.eContainer();
        final String aProtocolName = ((AvroIDLFile) _eContainer_1).getName();
        for (int j = 0; (j < ((Object[])Conversions.unwrapArray(bRules, Object.class)).length); j++) {
          {
            final String bSchemaName = (((ChangeEnum[])Conversions.unwrapArray(bRules, ChangeEnum.class))[j]).getSchema().getName();
            EObject _eContainer_2 = (((ChangeEnum[])Conversions.unwrapArray(bRules, ChangeEnum.class))[j]).getSchema().eContainer();
            final TypeDef bSchemaContainer = ((TypeDef) _eContainer_2);
            EObject _eContainer_3 = bSchemaContainer.eContainer();
            final String bProtocolName = ((AvroIDLFile) _eContainer_3).getName();
            if ((aSchemaName.equals(bSchemaName) && aProtocolName.equals(bProtocolName))) {
              this.warning(
                String.format("CONCURENT MODIFICATION ERROR: %s is edited in %s and %s", 
                  ((aProtocolName + ".") + aSchemaName), a.getName(), b.getName()), 
                AeditPackage.Literals.RULE_MAP__RULES, index);
              this.getVarDeleteConflicts(((GenericRule[])Conversions.unwrapArray(aRules, GenericRule.class))[i], ((GenericRule[])Conversions.unwrapArray(bRules, GenericRule.class))[j], a.getName(), b.getName());
              this.getVarRenameConflicts(((GenericRule[])Conversions.unwrapArray(aRules, GenericRule.class))[i], ((GenericRule[])Conversions.unwrapArray(bRules, GenericRule.class))[j], a.getName(), b.getName());
            }
          }
        }
      }
    }
  }
  
  public Field getVariable(final String currentProtocol, final String currentSchema, final String fieldName) {
    final Function1<Field, Boolean> _function = (Field it) -> {
      return Boolean.valueOf(it.getName().equals(fieldName));
    };
    List<Field> field = IteratorExtensions.<Field>toList(IteratorExtensions.<Field>filter(Iterators.<Field>filter(AeditValidator.protocols.get(currentProtocol).eAllContents(), Field.class), _function));
    final Function1<Field, Boolean> _function_1 = (Field it) -> {
      EObject _eContainer = it.eContainer();
      return Boolean.valueOf(((RecordType) _eContainer).getName().equals(currentSchema));
    };
    return IterableExtensions.<Field>toList(IterableExtensions.<Field>filter(field, _function_1)).get(0);
  }
  
  public boolean isUnique(final String fullName) {
    if ((this.newVariables.contains(fullName) || this.existingVariables.contains(fullName))) {
      boolean _contains = this.removedVariables.contains(fullName);
      if (_contains) {
        return false;
      }
      return true;
    }
    return false;
  }
  
  public void getVarDeleteConflicts(final GenericRule a, final GenericRule b, final String aName, final String bName) {
    if (((a instanceof ChangeEnum) && (b instanceof ChangeEnum))) {
      this.checkConcurrentEnumDelete(Iterables.<RemoveEnum>filter(IteratorExtensions.<EObject>toIterable(a.eAllContents()), RemoveEnum.class), 
        Iterables.<RemoveEnum>filter(IteratorExtensions.<EObject>toIterable(b.eAllContents()), RemoveEnum.class), aName, bName);
    } else {
      if (((a instanceof ChangeSchema) && (b instanceof ChangeSchema))) {
        this.checkConcurrentVarDelete(Iterables.<RemoveVariable>filter(IteratorExtensions.<EObject>toIterable(a.eAllContents()), RemoveVariable.class), 
          Iterables.<RemoveVariable>filter(IteratorExtensions.<EObject>toIterable(b.eAllContents()), RemoveVariable.class), aName, bName);
      }
    }
  }
  
  public void getVarRenameConflicts(final GenericRule a, final GenericRule b, final String aName, final String bName) {
    if (((a instanceof ChangeEnum) && (b instanceof ChangeEnum))) {
      this.checkConcurrentEnumRename(Iterables.<RenameEnum>filter(IteratorExtensions.<EObject>toIterable(a.eAllContents()), RenameEnum.class), 
        Iterables.<RenameEnum>filter(IteratorExtensions.<EObject>toIterable(b.eAllContents()), RenameEnum.class), aName, bName);
    } else {
      if (((a instanceof ChangeSchema) && (b instanceof ChangeSchema))) {
        this.checkConcurrentVarRename(Iterables.<RenameVariable>filter(IteratorExtensions.<EObject>toIterable(a.eAllContents()), RenameVariable.class), 
          Iterables.<RenameVariable>filter(IteratorExtensions.<EObject>toIterable(b.eAllContents()), RenameVariable.class), aName, bName);
      }
    }
  }
  
  public void getVarSetTypeConflicts(final GenericRule a, final GenericRule b, final String aName, final String bName) {
    if (((a instanceof ChangeSchema) && (b instanceof ChangeSchema))) {
      this.checkConcurrentVarTypeChange(Iterables.<ChangeType>filter(IteratorExtensions.<EObject>toIterable(a.eAllContents()), ChangeType.class), 
        Iterables.<ChangeType>filter(IteratorExtensions.<EObject>toIterable(b.eAllContents()), ChangeType.class), aName, bName);
    }
  }
  
  public void getVarChangeDataConflicts(final GenericRule a, final GenericRule b, final String aName, final String bName) {
    if (((a instanceof ChangeSchema) && (b instanceof ChangeSchema))) {
      this.checkConcurrentVarValueChange(Iterables.<ChangeDefValue>filter(IteratorExtensions.<EObject>toIterable(a.eAllContents()), ChangeDefValue.class), 
        Iterables.<ChangeDefValue>filter(IteratorExtensions.<EObject>toIterable(b.eAllContents()), ChangeDefValue.class), aName, bName);
    }
  }
  
  public void checkConcurrentEnumDelete(final Iterable<RemoveEnum> alist, final Iterable<RemoveEnum> blist, final String aRuleName, final String bRuleName) {
    List<String> deletedEnumsA = new ArrayList<String>();
    List<String> deletedEnumsB = new ArrayList<String>();
    for (final RemoveEnum removeEnumRule : alist) {
      deletedEnumsA.add(removeEnumRule.getVarName());
    }
    for (final RemoveEnum removeEnumRule_1 : blist) {
      deletedEnumsB.add(removeEnumRule_1.getVarName());
    }
    this.displayVarErrors(deletedEnumsA, deletedEnumsB, aRuleName, bRuleName, "deleted");
  }
  
  public void checkConcurrentVarDelete(final Iterable<RemoveVariable> alist, final Iterable<RemoveVariable> blist, final String aRuleName, final String bRuleName) {
    List<String> deletedVarsA = new ArrayList<String>();
    List<String> deletedVarsB = new ArrayList<String>();
    for (final RemoveVariable removeVarRule : alist) {
      deletedVarsA.add(removeVarRule.getVariable().getName());
    }
    for (final RemoveVariable removeVarRule_1 : blist) {
      deletedVarsB.add(removeVarRule_1.getVariable().getName());
    }
    this.displayVarErrors(deletedVarsA, deletedVarsB, aRuleName, bRuleName, "deleted");
  }
  
  public void checkConcurrentEnumRename(final Iterable<RenameEnum> alist, final Iterable<RenameEnum> blist, final String aRuleName, final String bRuleName) {
    List<String> renamedVarsA = new ArrayList<String>();
    List<String> renamedVarsB = new ArrayList<String>();
    for (final RenameEnum renameEnumRule : alist) {
      renamedVarsA.add(renameEnumRule.getOldName());
    }
    for (final RenameEnum renameEnumRule_1 : blist) {
      renamedVarsB.add(renameEnumRule_1.getOldName());
    }
    this.displayVarErrors(renamedVarsA, renamedVarsB, aRuleName, bRuleName, "renamed");
  }
  
  public void checkConcurrentVarRename(final Iterable<RenameVariable> alist, final Iterable<RenameVariable> blist, final String aRuleName, final String bRuleName) {
    List<String> renamedVarsA = new ArrayList<String>();
    List<String> renamedVarsB = new ArrayList<String>();
    for (final RenameVariable renameVarRule : alist) {
      renamedVarsA.add(renameVarRule.getVariable().getName());
    }
    for (final RenameVariable renameVarRule_1 : blist) {
      renamedVarsB.add(renameVarRule_1.getVariable().getName());
    }
    this.displayVarErrors(renamedVarsA, renamedVarsB, aRuleName, bRuleName, "renamed");
  }
  
  public void checkConcurrentVarTypeChange(final Iterable<ChangeType> alist, final Iterable<ChangeType> blist, final String aRuleName, final String bRuleName) {
    List<String> changedVarsA = new ArrayList<String>();
    List<String> changedVarsB = new ArrayList<String>();
    for (final ChangeType changeTypeRule : alist) {
      changedVarsA.add(changeTypeRule.getField().getName());
    }
    for (final ChangeType changeTypeRule_1 : blist) {
      changedVarsB.add(changeTypeRule_1.getField().getName());
    }
    this.displayVarErrors(changedVarsA, changedVarsB, aRuleName, bRuleName, "modified (set_type)");
  }
  
  public void checkConcurrentVarValueChange(final Iterable<ChangeDefValue> alist, final Iterable<ChangeDefValue> blist, final String aRuleName, final String bRuleName) {
    List<String> changedVarsA = new ArrayList<String>();
    List<String> changedVarsB = new ArrayList<String>();
    for (final ChangeDefValue changeValRule : alist) {
      changedVarsA.add(changeValRule.getField().getName());
    }
    for (final ChangeDefValue changeValRule_1 : blist) {
      changedVarsB.add(changeValRule_1.getField().getName());
    }
    this.displayVarErrors(changedVarsA, changedVarsB, aRuleName, bRuleName, "modified (set_val)");
  }
  
  public void displayVarErrors(final List<String> listA, final List<String> listB, final String aRuleName, final String bRuleName, final String errMessage) {
    int _length = ((Object[])Conversions.unwrapArray(listA, Object.class)).length;
    int _length_1 = ((Object[])Conversions.unwrapArray(listB, Object.class)).length;
    boolean _greaterEqualsThan = (_length >= _length_1);
    if (_greaterEqualsThan) {
      listA.retainAll(listB);
      for (final String varName : listA) {
        this.error(
          String.format("CONCURRENT MODIFICATION ERROR: %s is %s in %s and %s", varName, errMessage, aRuleName, bRuleName), AeditPackage.Literals.RULE_MAP__RULES, this.currentRuleIndex);
      }
    } else {
      listB.retainAll(listA);
      for (final String varName_1 : listB) {
        this.error(
          String.format("CONCURRENT MODIFICATION ERROR: %s is %s in %s and %s", varName_1, errMessage, aRuleName, bRuleName), AeditPackage.Literals.RULE_MAP__RULES, this.currentRuleIndex);
      }
    }
  }
}
