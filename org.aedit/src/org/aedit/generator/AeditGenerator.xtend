/*
 * generated by Xtext 2.12.0
 */
package org.aedit.generator

import HelperClass.HelperClass
import java.io.File
import java.util.HashMap
import java.util.Map
import org.aedit.aedit.Add
import org.aedit.aedit.AddEnum
import org.aedit.aedit.AddEnumeration
import org.aedit.aedit.AddRecord
import org.aedit.aedit.AddVariable
import org.aedit.aedit.ChangeDefValue
import org.aedit.aedit.ChangeEnum
import org.aedit.aedit.ChangeSchema
import org.aedit.aedit.EnumRule
import org.aedit.aedit.Feature
import org.aedit.aedit.FeatureMap
import org.aedit.aedit.GenericRule
import org.aedit.aedit.RemoveEnum
import org.aedit.aedit.RemoveSchema
import org.aedit.aedit.RemoveVariable
import org.aedit.aedit.RenameEnum
import org.aedit.aedit.RenameSchema
import org.aedit.aedit.RenameVariable
import org.aedit.aedit.RuleDeclaration
import org.aedit.aedit.RuleMap
import org.aedit.aedit.SchemaRule
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myAvdl.AvroIDLFile
import org.xtext.example.mydsl.myAvdl.EnumType
import org.xtext.example.mydsl.myAvdl.MyAvdlFactory
import org.xtext.example.mydsl.myAvdl.RecordType
import org.xtext.example.mydsl.myAvdl.TypeDef
import org.xtext.example.mydsl.myAvdl.Value
import java.io.PrintWriter
import java.nio.file.Files
import java.nio.file.Paths
import java.util.Properties
import org.aedit.aedit.ChangeType
import org.aedit.aedit.IntValue
import org.aedit.aedit.FloatValue
import org.aedit.aedit.StringValue

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AeditGenerator extends AbstractGenerator {

	private Map<String, AvroIDLFile> protocols = new HashMap<String, AvroIDLFile>();
	private String filePath = "D:\\School\\runtime-EclipseXtext\\Testbench\\src\\avdl";

	private String currentProtocol;
	private String currentSchema;
	private int index;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		protocols = HelperClass.getAvroFiles(resource)

		if (!resource.allContents.toIterable.filter(FeatureMap).empty) {
			// Traverse the AST
			for (e : resource.allContents.toIterable.filter(FeatureMap)) {
				e.compile
			} 
			// Save the newly edited models
			protocols.forEach [ p1, p2 |
				saveAvroIDLFile(
					URI.createURI("platform:/resource/Testbench/src-gen/m2m-gen/GEN" + p1 + ".myavdl"),
					p2
				)
			]
		}

	}

	// Helper methods for importing avdl files
	def loadAvroIDLFile(URI uri, Resource resource) {

		// Load the model from the original file
		val res = resource.resourceSet.getResource(uri, true)
		val originalAvroFile = res.contents.get(0) as AvroIDLFile

		// Create a copy, otherwise cross references can be messed up during the editing
		val copyAvroFile = EcoreUtil2.copy(originalAvroFile)

		return copyAvroFile
	}

	def saveAvroIDLFile(URI uri, AvroIDLFile newModel) {
		var Resource rs = new ResourceSetImpl().createResource(uri);
		rs.getContents.add(newModel);
		// val Map<Object, Object> saveOptions = new HashMap<Object, Object>();
		// Use formatter for pretty printing of the new .avdl files.
		rs.save(null)

		// REMOVE WHEN USING Avroclipse
		myavdl2avdl
	}

	// TODO:REMOVE
	def myavdl2avdl() {

//		deleteDir(new File("D:\\School\\runtime-EclipseXtext\\Testbench\\src-gen\\avdl-gen\\"))

		val path = "D:\\School\\runtime-EclipseXtext\\Testbench\\src-gen\\m2m-gen\\"
		val dir = new File(path)
		val directoryListing = dir.listFiles();
		
		for (file : directoryListing){
			val newFileName = file.name.replace("myavdl", "avdl")
			val newFile = new File("D:\\School\\runtime-EclipseXtext\\Testbench\\src-gen\\avdl-gen\\"+newFileName)
			newFile.createNewFile
			val prw = new PrintWriter(newFile.absolutePath)
			prw.println(new String(Files.readAllBytes(Paths.get(file.path))))
			prw.close
		}

	}

	// TODO:REMOVE
	def deleteDir(File dir) {
		for (file : dir.listFiles) {
			if (!file.isDirectory) {
				file.delete
			}
		}
	}

	def compile(FeatureMap featureMap) {
		featureMap.name.compile
	}

	def compile(Feature feature) {
		if (feature.extend !== null) {
			feature.extend.compile
		}
		for (ruleMap : feature.ruleMaps) {
			ruleMap.compile
		}
	}

	def compile(RuleMap ruleMap) {
		for (ruleDeclaration : ruleMap.rules) {
			ruleDeclaration.compile
		}
	}

	def compile(RuleDeclaration ruleDeclaration) {
		for (rule : ruleDeclaration.rules) {
			rule.compile
		}
	}

	def compile(GenericRule genRule) {
		switch (genRule) {
			RenameSchema: genRule.compile
			RemoveSchema: genRule.compile
			Add: genRule.compile
			ChangeSchema: genRule.compile
			ChangeEnum: genRule.compile
		}
	}

	def compile(RenameSchema renameSchema) {

		// Get name of the schema
		val schemaName = renameSchema.schema.name
		// Get name of the protocol
		var schemaContainer = renameSchema.schema.eContainer as TypeDef
		val protocolName = (schemaContainer.eContainer as AvroIDLFile).name

		protocols.get(protocolName).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof RecordType) {
				if ((typeDef.type as RecordType).name.equals(schemaName)) {
					(typeDef.type as RecordType).name = renameSchema.newSchName
				}
			} else if (typeDef.type instanceof EnumType) {
				if ((typeDef.type as EnumType).name.equals(schemaName)) {
					(typeDef.type as EnumType).name = renameSchema.newSchName
				}
			}

		]

	}

	def compile(RemoveSchema removeSchema) {

		// Get name of the schema
		val schemaName = removeSchema.schema.name
		// Get name of the protocol
		var schemaContainer = removeSchema.schema.eContainer as TypeDef
		val protocolName = (schemaContainer.eContainer as AvroIDLFile).name
		protocols.get(protocolName).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof RecordType) {
				if ((typeDef.type as RecordType).name.equals(schemaName)) {
					index = protocols.get(protocolName).elements.indexOf(typeDef)
				}
			} else if (typeDef.type instanceof EnumType) {
				if ((typeDef.type as EnumType).name.equals(schemaName)) {
					index = protocols.get(protocolName).elements.indexOf(typeDef)
				}
			}
		]

		protocols.get(protocolName).elements.remove(index)
	}

	def compile(Add add) {
		switch (add) {
			AddRecord: add.compile
			AddEnumeration: add.compile
		}
	}

	def compile(AddRecord addRecord) {

		// Get name of the schema
		val schemaName = addRecord.recordName
		// Get name of the protocol
		val protocolName = addRecord.namespace.name

		val TypeDef newTypeDef = MyAvdlFactory.eINSTANCE.createTypeDef
		newTypeDef.type = MyAvdlFactory.eINSTANCE.createRecordType => [
			name = schemaName

			addRecord.fields.forEach [ field |
				fields.add(HelperClass.createField(field))
			]
		]

		protocols.get(protocolName).elements.add(addRecord.index, newTypeDef)
	}

	def compile(AddEnumeration addEnumeration) {

		// Get name of the schema 
		val schemaName = addEnumeration.enumName
		// Get name of the protocol
		val protocolName = addEnumeration.namespace.name

		val TypeDef newTypeDef = MyAvdlFactory.eINSTANCE.createTypeDef
		newTypeDef.type = MyAvdlFactory.eINSTANCE.createEnumType => [
			name = schemaName

			addEnumeration.symbols.forEach [ symbol |
				literals.add(symbol)
			]
		]

		protocols.get(protocolName).elements.add(addEnumeration.index, newTypeDef)
	}

	def compile(ChangeSchema changeSchema) {

		// Get name of the schema
		currentSchema = changeSchema.schema.name
		// Get name of the protocol
		var schemaContainer = changeSchema.schema.eContainer as TypeDef
		currentProtocol = (schemaContainer.eContainer as AvroIDLFile).name

		for (rule : changeSchema.rules) {
			rule.compile
		}
	}

	def compile(SchemaRule schemaRule) {
		switch (schemaRule) {
			RemoveVariable: schemaRule.compile
			RenameVariable: schemaRule.compile
			AddVariable: schemaRule.compile
			ChangeDefValue: schemaRule.compile
			ChangeType: schemaRule.compile
		}
	}

	def compile(RemoveVariable removeVariable) {
		protocols.get(currentProtocol).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof RecordType) {
				if ((typeDef.type as RecordType).name.equals(currentSchema)) {
					(typeDef.type as RecordType).fields.removeIf[it.name.equals(removeVariable.variable.name)]
				}
			}
		]
	}

	def compile(RenameVariable renameVariable) {
		protocols.get(currentProtocol).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof RecordType) {
				if ((typeDef.type as RecordType).name.equals(currentSchema)) {
					(typeDef.type as RecordType).fields.filter[it.name.equals(renameVariable.variable.name)].forEach [ field |
						field.name = renameVariable.newVarName
					]
				}
			}
		]
	}

	def compile(AddVariable addVariable) {
		protocols.get(currentProtocol).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof RecordType) {
				if (typeDef.type.name.equals(currentSchema)) {
					(typeDef.type as RecordType).fields.add(addVariable.index, HelperClass.createField(addVariable.newVar))
				}
			}
		]
	}

	def compile(ChangeDefValue changeDefValue) {
		protocols.get(currentProtocol).elements.filter(TypeDef).filter[type instanceof RecordType].forEach [ typeDef |
			if ((typeDef.type as RecordType).name.equals(currentSchema)) {
				(typeDef.type as RecordType).fields.filter[it.name.equals(changeDefValue.field.name)].forEach [ field |

					val newVal = changeDefValue.newVal
					var Value newDefValue;

					switch (newVal) {
						case newVal instanceof IntValue:
							newDefValue = MyAvdlFactory.eINSTANCE.createIntValue => [
								^val = (newVal as IntValue).^val
							]
						case newVal instanceof FloatValue:
							newDefValue = MyAvdlFactory.eINSTANCE.createFloatValue => [
								^val = (newVal as FloatValue).^val
							]
						case newVal instanceof IntValue:
							newDefValue = MyAvdlFactory.eINSTANCE.createIntValue => [
								^val = (newVal as IntValue).^val
							]
						default:
							newDefValue = MyAvdlFactory.eINSTANCE.createStringValue => [
								^val = (newVal as StringValue).^val
							]
					}

					field.^default = newDefValue

				]
			}
		]
	}
	
	def compile(ChangeType changeType){
		protocols.get(currentProtocol).elements.filter(TypeDef).filter[type instanceof RecordType].forEach [ typeDef |
			if ((typeDef.type as RecordType).name.equals(currentSchema)) {
				(typeDef.type as RecordType).fields.filter[it.name.equals(changeType.field.name)].forEach [ field |

					field.type = MyAvdlFactory.eINSTANCE.createPrimativeTypeLink=>[
						target = changeType.newType
					]

				]
			}
		]
	}

	def compile(ChangeEnum changeEnum) {
		// Get name of the schema
		currentSchema = changeEnum.schema.name
		// Get name of the protocol
		var schemaContainer = changeEnum.schema.eContainer as TypeDef
		currentProtocol = (schemaContainer.eContainer as AvroIDLFile).name

		for (rule : changeEnum.rules) {
			rule.compile
		}
	}

	def compile(EnumRule enumRule) {
		switch (enumRule) {
			RemoveEnum: enumRule.compile
			RenameEnum: enumRule.compile
			AddEnum: enumRule.compile
		}
	}

	def compile(RemoveEnum removeEnum) {
		protocols.get(currentProtocol).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof EnumType) {
				if ((typeDef.type as EnumType).name.equals(currentSchema)) {
					(typeDef.type as EnumType).literals.removeIf[it.equals(removeEnum.varName)]
				}
			}

		]
	}

	def compile(RenameEnum renameEnum) {
		protocols.get(currentProtocol).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof EnumType) {
				if ((typeDef.type as EnumType).name.equals(currentSchema)) {
					(typeDef.type as EnumType).literals.set(
						(typeDef.type as EnumType).literals.indexOf(renameEnum.oldName), renameEnum.newEnumName)
				}
			}

		]
	}

	def compile(AddEnum addEnum) {
		protocols.get(currentProtocol).elements.filter(TypeDef).forEach [ typeDef |
			if (typeDef.type instanceof EnumType) {
				if (typeDef.type.name.equals(currentSchema)) {
					(typeDef.type as EnumType).literals.add(addEnum.index, addEnum.varName)
				}
			}
		]
	}
}
