/*
 * generated by Xtext 2.12.0
 */
package org.aedit.validation

import HelperClass.HelperClass
import avroclipse.avroIDL.Array
import avroclipse.avroIDL.ArrayFieldType
import avroclipse.avroIDL.AvroIDLFactory
import avroclipse.avroIDL.AvroIDLFile
import avroclipse.avroIDL.Field
import avroclipse.avroIDL.PrimativeTypeLink
import avroclipse.avroIDL.RecordType
import avroclipse.avroIDL.TypeDef
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import org.aedit.aedit.AddAnnotationToField
import org.aedit.aedit.AddAnnotationToSchema
import org.aedit.aedit.AddEnum
import org.aedit.aedit.AddEnumeration
import org.aedit.aedit.AddNameAnnotationToField
import org.aedit.aedit.AddRecord
import org.aedit.aedit.AddValueToArray
import org.aedit.aedit.AddVariable
import org.aedit.aedit.AeditPackage
import org.aedit.aedit.ChangeDefValue
import org.aedit.aedit.ChangeEnum
import org.aedit.aedit.ChangeSchema
import org.aedit.aedit.ChangeType
import org.aedit.aedit.FloatValue
import org.aedit.aedit.GenericRule
import org.aedit.aedit.IntValue
import org.aedit.aedit.Model
import org.aedit.aedit.PrimitiveTypeField
import org.aedit.aedit.RemoveAnnotationFromField
import org.aedit.aedit.RemoveAnnotationFromSchema
import org.aedit.aedit.RemoveArrayValue
import org.aedit.aedit.RemoveArrayValueAtIndex
import org.aedit.aedit.RemoveEnum
import org.aedit.aedit.RemoveNameAnnotationFromField
import org.aedit.aedit.RemoveSchema
import org.aedit.aedit.RemoveVariable
import org.aedit.aedit.RenameEnum
import org.aedit.aedit.RenameSchema
import org.aedit.aedit.RenameVariable
import org.aedit.aedit.RuleDeclaration
import org.aedit.aedit.RuleMap
import org.aedit.aedit.StringValue
import org.aedit.aedit.Value
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AeditValidator extends AbstractAeditValidator {

	static Map<String, AvroIDLFile> protocols = new HashMap<String, AvroIDLFile>();

	List<String> removedVariables = new ArrayList<String>()
	List<String> removedAnnotations = new ArrayList<String>()
	List<String> removedNameAnnotations = new ArrayList<String>()

	List<String> existingVariables = new ArrayList<String>()
	List<String> existingAnnotations = new ArrayList<String>()
	List<String> existingNameAnnotations = new ArrayList<String>()

	List<String> newVariables = new ArrayList<String>()
	List<String> newAnnotations = new ArrayList<String>()
	List<String> newNameAnnotations = new ArrayList<String>()

	HashMap<String, Integer> arraySizes = new HashMap<String, Integer>();

	String currentSchema;
	String currentProtocol;

	@Check
	def checkModel(Model model) {
		protocols.clear
		existingAnnotations.clear
		existingNameAnnotations.clear
		existingVariables.clear

		if (protocols.empty) {
			protocols = HelperClass.getAvroFiles(model.eResource)
			protocols.forEach [ p1, p2 |
				existingVariables.addAll(
					HelperClass.getSchemasAndFields(p2, existingAnnotations, existingNameAnnotations))
			]
		}
	}

	@Check
	def checkRuleDeclaration(RuleDeclaration ruleDeclaration) {

		arraySizes.clear
		removedVariables.clear
		newVariables.clear
		newAnnotations.clear
		newNameAnnotations.clear
		removedAnnotations.clear
		removedNameAnnotations.clear

	}

	@Check
	def checkChangeSchema(ChangeSchema changeSchema) {
		// Get name of the schema
		currentSchema = changeSchema.schema.name
		// Get name of the protocol
		var schemaContainer = changeSchema.schema.eContainer as TypeDef
		currentProtocol = (schemaContainer.eContainer as AvroIDLFile).name

		var fullName = currentProtocol + '.' + currentSchema

		if (!HelperClass.checkIfTypeIsCorrect(changeSchema.schemaType, changeSchema.schema)) {
			error(ErrorMessages.TYPE_MISSMATCH, AeditPackage.Literals.CHANGE_SCHEMA__SCHEMA_TYPE,
				ErrorCodes.CHANGE_SCHEMA)
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_SCHEMA, AeditPackage.Literals.CHANGE_SCHEMA__SCHEMA, ErrorCodes.CHANGE_SCHEMA,
				fullName)
		}
	}

	@Check
	def checkChangeEnum(ChangeEnum changeEnum) {
		// Get name of the schema
		currentSchema = changeEnum.schema.name
		// Get name of the protocol
		var schemaContainer = changeEnum.schema.eContainer as TypeDef
		currentProtocol = (schemaContainer.eContainer as AvroIDLFile).name

		var fullName = currentProtocol + '.' + currentSchema

		if (removedVariables.contains(fullName)) {
			error("Schema does not exist!", AeditPackage.Literals.CHANGE_ENUM__SCHEMA, ErrorCodes.CHANGE_ENUM, fullName)
		}
	}

	@Check
	def checkRemoveVariable(RemoveVariable removeVariable) {

		var fullName = currentProtocol + '.' + currentSchema + '.' + removeVariable.variable.name

		if (!isFieldInSchema(removeVariable.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.REMOVE_VARIABLE__VARIABLE, ErrorCodes.REMOVE_VARIABLE)) {
			return null
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_FIELD, AeditPackage.Literals.REMOVE_VARIABLE__VARIABLE,
				ErrorCodes.REMOVE_VARIABLE)
			return null
		} else {
			removedVariables.add(fullName)
		}

	}

	@Check
	def checkRenameVariable(RenameVariable renameVariable) {

		var oldVar = currentProtocol + '.' + currentSchema + '.' + renameVariable.variable.name
		var newVar = currentProtocol + '.' + currentSchema + '.' + renameVariable.newVarName

		if (!isFieldInSchema(renameVariable.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.RENAME_VARIABLE__VARIABLE, ErrorCodes.RENAME_VARIABLE)) {
			return null
		}

		if (removedVariables.contains(oldVar)) {
			error(ErrorMessages.DELETED_FIELD, AeditPackage.Literals.RENAME_VARIABLE__VARIABLE,
				ErrorCodes.RENAME_VARIABLE)
			return null
		}

		if (isUnique(newVar)) {
			error(ErrorMessages.DUPLICATE_FIELD, AeditPackage.Literals.RENAME_VARIABLE__NEW_VAR_NAME,
				ErrorCodes.DUPLICATE_FIELD)
		} else {
			removedVariables.add(oldVar)
		}

	}

	@Check
	def checkRemoveSchema(RemoveSchema removeSchema) {
		// Get name of the schema
		val schemaName = removeSchema.schema.name
		// Get name of the protocol
		var schemaContainer = removeSchema.schema.eContainer as TypeDef
		val protocolName = (schemaContainer.eContainer as AvroIDLFile).name

		var fullName = protocolName + '.' + schemaName

		if (!HelperClass.checkIfTypeIsCorrect(removeSchema.schemaType, removeSchema.schema)) {
			error(ErrorMessages.TYPE_MISSMATCH, AeditPackage.Literals.REMOVE_SCHEMA__SCHEMA_TYPE,
				ErrorCodes.REMOVE_SCHEMA)
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_SCHEMA, AeditPackage.Literals.REMOVE_SCHEMA__SCHEMA, ErrorCodes.REMOVE_SCHEMA)
		} else {
			removedVariables.add(fullName)
		}
	}

	@Check
	def checkRenameSchema(RenameSchema renameSchema) {
		// Get name of the schema
		val schemaName = renameSchema.schema.name
		// Get name of the protocol
		var schemaContainer = renameSchema.schema.eContainer as TypeDef
		val protocolName = (schemaContainer.eContainer as AvroIDLFile).name

		var fullName = protocolName + '.' + schemaName

		if (!HelperClass.checkIfTypeIsCorrect(renameSchema.schemaType, renameSchema.schema)) {
			error(ErrorMessages.TYPE_MISSMATCH, AeditPackage.Literals.RENAME_SCHEMA__SCHEMA_TYPE,
				ErrorCodes.RENAME_SCHEMA)
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_SCHEMA, AeditPackage.Literals.RENAME_SCHEMA__SCHEMA, ErrorCodes.RENAME_SCHEMA)
		} else {
			removedVariables.add(fullName)
		}
	}

	@Check
	def checkAddAnnotationToSchema(AddAnnotationToSchema addAnnotationToSchema) {
		// Get name of the schema
		val schemaName = addAnnotationToSchema.schema.name
		// Get name of the protocol
		var schemaContainer = addAnnotationToSchema.schema.eContainer as TypeDef
		val protocolName = (schemaContainer.eContainer as AvroIDLFile).name

		var fullName = protocolName + '.' + schemaName + '.' + addAnnotationToSchema.annotation.name

		// Check if the specified type and the schema's type are the same
		if (!HelperClass.checkIfTypeIsCorrect(addAnnotationToSchema.schemaType, addAnnotationToSchema.schema)) {
			error(ErrorMessages.TYPE_MISSMATCH, AeditPackage.Literals.ADD_ANNOTATION_TO_SCHEMA__SCHEMA_TYPE,
				ErrorCodes.ADD_ANNOTATION_TO_SCHEMA, fullName)
		}

		// Check if annotation is already defined
		if (existingAnnotations.contains(fullName) || newAnnotations.contains(fullName)) {
			error(ErrorMessages.DUPLICATE_ANNOTATION, AeditPackage.Literals.ADD_ANNOTATION_TO_SCHEMA__ANNOTATION,
				ErrorCodes.DUPLICATE_ANNOTATION, fullName)
		} else {
			newAnnotations.add(fullName)
		}

	}

	@Check
	def checkRemoveAnnotationFromSchema(RemoveAnnotationFromSchema removeAnnotationFromSchema) {
		// Get name of the schema
		val schemaName = removeAnnotationFromSchema.schema.name
		// Get name of the protocol
		var schemaContainer = removeAnnotationFromSchema.schema.eContainer as TypeDef
		val protocolName = (schemaContainer.eContainer as AvroIDLFile).name

		var fullName = protocolName + '.' + schemaName

		// Check if the specified type and the schema's type are the same
		if (!HelperClass.checkIfTypeIsCorrect(removeAnnotationFromSchema.schemaType,
			removeAnnotationFromSchema.schema)) {
			error(ErrorMessages.TYPE_MISSMATCH, AeditPackage.Literals.REMOVE_ANNOTATION_FROM_SCHEMA__SCHEMA_TYPE,
				ErrorCodes.REMOVE_ANNOTATION_FROM_SCHEMA)
		}

		val annotationToRemoveNamaspace = HelperClass.getAnnotationQualifiedName(
			removeAnnotationFromSchema.annotationToRemove)

		// Check if the annotation belongs to the current schema
		if (!annotationToRemoveNamaspace.equals(fullName)) {
			error(ErrorMessages.ANNOTATION_NOT_IN_SCHEMA,
				AeditPackage.Literals.REMOVE_ANNOTATION_FROM_SCHEMA__ANNOTATION_TO_REMOVE,
				ErrorCodes.REMOVE_ANNOTATION_FROM_SCHEMA, fullName)
		}
	}

	@Check
	def checkAddAnnotationToField(AddAnnotationToField addAnnotationToField) {

		if (!isFieldInSchema(addAnnotationToField.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.ADD_ANNOTATION_TO_FIELD__VARIABLE, ErrorCodes.ADD_ANNOTATION_TO_FIELD)) {
			return null
		}

		var annotationFullName = currentProtocol + '.' + currentSchema + '.' + addAnnotationToField.variable.name +
			'.' + addAnnotationToField.annotation.name

		if (existingAnnotations.contains(annotationFullName) || newAnnotations.contains(annotationFullName)) {
			error(ErrorMessages.DUPLICATE_ANNOTATION, AeditPackage.Literals.ADD_ANNOTATION_TO_FIELD__ANNOTATION,
				ErrorCodes.DUPLICATE_ANNOTATION, annotationFullName)
		} else {
			newAnnotations.add(annotationFullName)
		}

	}

	@Check
	def checkAddNameAnnotationToField(AddNameAnnotationToField addNameAnnotationToField) {

		if (!isFieldInSchema(addNameAnnotationToField.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.ADD_NAME_ANNOTATION_TO_FIELD__VARIABLE, ErrorCodes.ADD_NAME_ANNOTATION_TO_FIELD)) {
			return null
		}

		var annotationFullName = currentProtocol + '.' + currentSchema + '.' + addNameAnnotationToField.variable.name +
			'.' + addNameAnnotationToField.annotation.name

		if (existingNameAnnotations.contains(annotationFullName) || newNameAnnotations.contains(annotationFullName)) {
			error(ErrorMessages.DUPLICATE_ANNOTATION, AeditPackage.Literals.ADD_NAME_ANNOTATION_TO_FIELD__ANNOTATION,
				ErrorCodes.DUPLICATE_ANNOTATION, annotationFullName)
		} else {
			newNameAnnotations.add(annotationFullName)
		}
	}

	@Check
	def checkRemoveAnnotationFromField(RemoveAnnotationFromField removeAnnotationFromField) {

		if (!isFieldInSchema(removeAnnotationFromField.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.REMOVE_ANNOTATION_FROM_FIELD__VARIABLE, ErrorCodes.REMOVE_ANNOTATION_FROM_FIELD)) {
			return null
		}

		val annotationToRemoveNamaspace = HelperClass.getAnnotationQualifiedName(
			removeAnnotationFromField.annotationToRemove)

		val annotationToRemoveFullName = annotationToRemoveNamaspace + '.' +
			removeAnnotationFromField.annotationToRemove.name

		val currentNamespace = currentProtocol + '.' + currentSchema + '.' + removeAnnotationFromField.variable.name

		// Check if the annotation belongs to the current schema
		if (!annotationToRemoveNamaspace.equals(currentNamespace)) {
			error(ErrorMessages.ANNOTATION_NOT_IN_FIELD,
				AeditPackage.Literals.REMOVE_ANNOTATION_FROM_FIELD__ANNOTATION_TO_REMOVE,
				ErrorCodes.REMOVE_ANNOTATION_FROM_FIELD, currentNamespace)
		}

		// Check if annotation has already been deleted
		if (removedAnnotations.contains(annotationToRemoveFullName)) {
			error(ErrorMessages.DELETED_ANNOTATION,
				AeditPackage.Literals.REMOVE_ANNOTATION_FROM_FIELD__ANNOTATION_TO_REMOVE,
				ErrorCodes.REMOVE_ANNOTATION_FROM_FIELD, currentNamespace)
		} else {
			removedAnnotations.add(annotationToRemoveFullName)
		}
	}

	@Check
	def checkRemoveNameAnnotationFromField(RemoveNameAnnotationFromField removeNameAnnotationFromField) {

		if (!isFieldInSchema(removeNameAnnotationFromField.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.REMOVE_NAME_ANNOTATION_FROM_FIELD__VARIABLE,
			ErrorCodes.REMOVE_NAME_ANNOTATION_FROM_FIELD)) {
			return null
		}

		val annotationToRemoveNamaspace = HelperClass.getAnnotationQualifiedName(
			removeNameAnnotationFromField.annotationToRemove)

		val annotationToRemoveFullName = annotationToRemoveNamaspace + '.' +
			removeNameAnnotationFromField.annotationToRemove.name

		val currentNamespace = currentProtocol + '.' + currentSchema + '.' + removeNameAnnotationFromField.variable.name

		// Check if the annotation belongs to the current schema
		if (!annotationToRemoveNamaspace.equals(currentNamespace)) {
			error(ErrorMessages.ANNOTATION_NOT_IN_FIELD,
				AeditPackage.Literals.REMOVE_NAME_ANNOTATION_FROM_FIELD__ANNOTATION_TO_REMOVE,
				ErrorCodes.REMOVE_NAME_ANNOTATION_FROM_FIELD, currentNamespace)
		}

		// Check if annotation has already been deleted
		if (removedNameAnnotations.contains(annotationToRemoveFullName)) {
			error(ErrorMessages.DELETED_ANNOTATION,
				AeditPackage.Literals.REMOVE_NAME_ANNOTATION_FROM_FIELD__ANNOTATION_TO_REMOVE,
				ErrorCodes.REMOVE_NAME_ANNOTATION_FROM_FIELD, currentNamespace)
		} else {
			removedNameAnnotations.add(annotationToRemoveFullName)
		}

	}

	@Check
	def checkRemoveEnumConstant(RemoveEnum removeEnum) {

		var fullName = currentProtocol + '.' + currentSchema + '.' + removeEnum.varName

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.REMOVED_ENUM_CONST, AeditPackage.Literals.REMOVE_ENUM__VAR_NAME, ErrorCodes.REMOVE_ENUM_CONST)
		} else if (!existingVariables.contains(fullName)) {
			error(ErrorMessages.NON_EXISTENT_ENUM_CONST, AeditPackage.Literals.REMOVE_ENUM__VAR_NAME, ErrorCodes.REMOVE_ENUM_CONST)
		} else {
			removedVariables.add(fullName)
		}

	}

	@Check
	def checkRenameEnumConstant(RenameEnum renameEnum) {

		var oldEnum = currentProtocol + '.' + currentSchema + '.' + renameEnum.oldName
		var newEnum = currentProtocol + '.' + currentSchema + '.' + renameEnum.newEnumName

		if (removedVariables.contains(oldEnum)) {
			error(ErrorMessages.REMOVED_ENUM_CONST, AeditPackage.Literals.RENAME_ENUM__OLD_NAME, ErrorCodes.RENAME_ENUM_CONSTANT)
		} else if (!existingVariables.contains(oldEnum)) {
			error(ErrorMessages.NON_EXISTENT_ENUM_CONST, AeditPackage.Literals.RENAME_ENUM__OLD_NAME, ErrorCodes.RENAME_ENUM_CONSTANT)
		}

		if (isUnique(newEnum)) {
			error(ErrorMessages.DUPLICATE_ENUM_CONST, AeditPackage.Literals.RENAME_ENUM__NEW_ENUM_NAME, ErrorCodes.DUPLICATE_ENUM_CONST)
		} else {
			removedVariables.add(oldEnum)
		}

	}

	@Check
	def checkChangeType(ChangeType changeType) {

		if (!isFieldInSchema(changeType.field, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.CHANGE_TYPE__FIELD, ErrorCodes.CHANGE_TYPE)) {
			return null
		}

		var variable = getVariable(currentProtocol, currentSchema, changeType.field.name).^default
		var fullName = currentProtocol + '.' + currentSchema + '.' + changeType.field.name

		if (removedVariables.contains(fullName)) {
			error(
				ErrorMessages.DELETED_FIELD,
				AeditPackage.Literals.CHANGE_TYPE__FIELD,
				ErrorCodes.CHANGE_TYPE
			)
		} else if (variable !== null) {

			var varType = changeType.field.type
			if (varType instanceof PrimativeTypeLink) {
				if (varType.target.equals('int')) {
					switch (changeType.newType) {
						case 'string':
							error(ErrorMessages.CONVERT_INT_TO_STRING, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'int':
							error(ErrorMessages.CONVERT_INT_TO_INT, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'boolean':
							error(ErrorMessages.CONVERT_INT_TO_BOOL, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
					}
				} else if (varType.target.equals('long')) {
					switch (changeType.newType) {
						case 'string':
							error(ErrorMessages.CONVERT_LONG_TO_STRING, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'int':
							error(ErrorMessages.CONVERT_LONG_TO_INT, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'double':
							error(ErrorMessages.CONVERT_LONG_TO_DOUBLE, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'long':
							error(ErrorMessages.CONVERT_LONG_TO_LONG, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'boolean':
							error(ErrorMessages.CONVERT_LONG_TO_BOOL, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
					}
				} else if (varType.target.equals('double')) {
					switch (changeType.newType) {
						case 'string':
							error(ErrorMessages.CONVERT_DOUBLE_TO_STRING, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'int':
							error(ErrorMessages.CONVERT_DOUBLE_TO_INT, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'double':
							error(ErrorMessages.CONVERT_DOUBLE_TO_DOUBLE, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
						case 'boolean':
							error(ErrorMessages.CONVERT_DOUBLE_TO_BOOL, AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE, ErrorCodes.TYPE_MISSMATCH)
					}

				} else if (varType.target.equals('string')) {
					switch (changeType.newType) {
						case 'string':
							error("Variable is already of type string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE)
					}
				}
			}
		} else {
			var varType = changeType.field.type
			if (varType instanceof PrimativeTypeLink) {
				if (varType.target.equals('int')) {
					switch (changeType.newType) {
						case 'int':
							error("Variable is already of type int!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE)
					}
				} else if (varType.target.equals('long')) {
					switch (changeType.newType) {
						case 'long':
							error("Variable is already of type long!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE)
					}
				} else if (varType.target.equals('double')) {
					switch (changeType.newType) {
						case 'double':
							error("Variable is already of type double!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE)
					}

				} else if (varType.target.equals('string')) {
					switch (changeType.newType) {
						case 'string':
							error("Variable is already of type string!", AeditPackage.Literals.CHANGE_TYPE__NEW_TYPE)
					}
				}
			}
		}

	}

	@Check
	def checkChangeDefValue(ChangeDefValue changeDefValue) {

		if (!isFieldInSchema(changeDefValue.field, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.CHANGE_DEF_VALUE__FIELD, ErrorCodes.CHANGE_DEF_VALUE)) {
			return null
		}

		var fullName = currentProtocol + '.' + currentSchema + '.' + changeDefValue.field.name

		if (!removedVariables.contains(fullName)) {

			var varType = changeDefValue.field.type
			if (varType instanceof PrimativeTypeLink) {
				if (varType.target.equals('int')) {
					switch (changeDefValue.newVal) {
						case changeDefValue.newVal instanceof StringValue:
							error(ErrorMessages.STRING_TO_INT, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
						case changeDefValue.newVal instanceof FloatValue:
							error(ErrorMessages.FLOAT_TO_INT, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
					}
				} else if (varType.target.equals('long')) {
					switch (changeDefValue.newVal) {
						case changeDefValue.newVal instanceof StringValue:
							error(ErrorMessages.STRING_TO_LONG, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
						case changeDefValue.newVal instanceof FloatValue:
							error(ErrorMessages.FLOAT_TO_LONG, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
					}
				} else if (varType.target.equals('double')) {
					switch (changeDefValue.newVal) {
						case changeDefValue.newVal instanceof StringValue:
							error(ErrorMessages.STRING_TO_DOUBLE, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
					}

				} else if (varType.target.equals('string')) {
					switch (changeDefValue.newVal) {
						case changeDefValue.newVal instanceof IntValue:
							error(ErrorMessages.INTEGER_TO_STRING, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
						case changeDefValue.newVal instanceof FloatValue:
							error(ErrorMessages.FLOAT_TO_STRING, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
					}
				} else if (varType.target.equals('float')) {
					switch (changeDefValue.newVal) {
						case changeDefValue.newVal instanceof StringValue:
							error(ErrorMessages.STRING_TO_FLOAT, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
					}
				} else if (varType.target.equals('boolean')) {
					switch (changeDefValue.newVal) {
						case changeDefValue.newVal instanceof IntValue:
							error(ErrorMessages.INTEGER_TO_BOOL, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
						case changeDefValue.newVal instanceof FloatValue:
							error(ErrorMessages.FLOAT_TO_BOOL, AeditPackage.Literals.CHANGE_DEF_VALUE__NEW_VAL, ErrorCodes.TYPE_MISSMATCH)
					}
				}
			}
		} else {
			error(ErrorMessages.DELETED_FIELD, AeditPackage.Literals.CHANGE_DEF_VALUE__FIELD,
				ErrorCodes.CHANGE_DEF_VALUE)
		}

	}

	@Check
	def checkAddRecord(AddRecord addRecord) {
		var recordName = addRecord.namespace.name + '.' + addRecord.recordName

		if (existingVariables.contains(recordName) || newVariables.contains(recordName)) {
			error(ErrorMessages.DUPLICATE_SCHEMA, AeditPackage.Literals.ADD_RECORD__RECORD_NAME, ErrorCodes.DUPLICATE_FIELD)
		} else {
			newVariables.add(recordName)

			for (field : addRecord.fields) {

				var newFieldName = HelperClass.getFieldName(field)
				var fullFieldName = recordName + '.' + newFieldName

				if (newVariables.contains(fullFieldName)) {
					error(ErrorMessages.DUPLICATE_FIELD, AeditPackage.Literals.ADD_RECORD__FIELDS,
						addRecord.fields.indexOf(field), ErrorCodes.DUPLICATE_FIELD)
				} else {
					newVariables.add(fullFieldName)
				}
			}
		}

	}

	@Check
	def checkAddEnumeration(AddEnumeration addEnumeration) {
		var enumName = addEnumeration.namespace.name + '.' + addEnumeration.enumName

		if (existingVariables.contains(enumName) || newVariables.contains(enumName)) {
			error(ErrorMessages.DUPLICATE_SCHEMA,
				AeditPackage.Literals.ADD_ENUMERATION__ENUM_NAME, ErrorCodes.DUPLICATE_FIELD)
		} else {

			newVariables.add(enumName)

			for (symbol : addEnumeration.symbols) {
				var symbolName = enumName + symbol
				if (newVariables.contains(symbol)) {
					error(ErrorMessages.DUPLICATE_ENUM_CONST, AeditPackage.Literals.ADD_ENUMERATION__SYMBOLS,
						addEnumeration.symbols.indexOf(symbol), ErrorCodes.DUPLICATE_ENUM_CONST)
				} else {
					newVariables.add(symbolName)
				}
			}
		}

	}

	@Check
	def checkAddEnumConstant(AddEnum addEnum) {
		var fullName = currentProtocol + '.' + currentSchema + '.' + addEnum.varName

		if (existingVariables.contains(fullName)) {
			error(ErrorMessages.DUPLICATE_ENUM_CONST, AeditPackage.Literals.ADD_ENUM__VAR_NAME,
				ErrorCodes.DUPLICATE_ENUM_CONST)
		}

	}

	@Check
	def checkAddVariable(AddVariable addVariable) {

		var newFieldName = HelperClass.getFieldName(addVariable.newVar)
		var fullName = currentProtocol + '.' + currentSchema + '.' + newFieldName

		if (!isUnique(fullName)) {
			newVariables.add(fullName)
		} else {
			error(ErrorMessages.DUPLICATE_FIELD, AeditPackage.Literals.ADD_VARIABLE__NEW_VAR,
				ErrorCodes.DUPLICATE_FIELD)
		}
	}

	@Check
	def checkField(PrimitiveTypeField field) {
		if (field.type.equals("long")) {
			if (field.value as Object instanceof String) {
				error("Cannot assign string value to long!", AeditPackage.Literals.PRIMITIVE_TYPE_FIELD__VALUE)
			}
		} else if (field.type.equals("double")) {
			if (field.value as Object instanceof String) {
				error("Cannot assign string value to double!", AeditPackage.Literals.PRIMITIVE_TYPE_FIELD__VALUE)
			}
		} else if (field.type.equals("int")) {
			if (field.value as Object instanceof String) {
				error("Cannot assign string value to int!", AeditPackage.Literals.PRIMITIVE_TYPE_FIELD__VALUE)
			}
		}
	}

	@Check
	def checkForConflicts(RuleMap rm) {
		
		var nameIsValid = false;
		
		for (value : SensorFeatures.Features.values){
			if (value.toString.equals(rm.name)){
				nameIsValid = true
			}
		}
		
		if (!nameIsValid){
			error(ErrorMessages.INVALID_NAME, AeditPackage.Literals.RULE_MAP__NAME, ErrorCodes.RULE_MAP)
				return null
		}
		
		if (existingVariables.contains("RuleMap." + rm.name)){
			error(ErrorMessages.DUPLICATE_NAME, AeditPackage.Literals.RULE_MAP__NAME, ErrorCodes.DUPLICATE_FIELD)
			return null
		}
		
		existingVariables.add("RuleMap." + rm.name)
		
		for (ruleDecl : rm.rules) {
			for (otherRuleDecl : rm.rules) {
				if (ruleDecl !== otherRuleDecl) {
					getDeleteConflicts(ruleDecl, otherRuleDecl, rm.rules.indexOf(ruleDecl))
					getSchemaEditConflicts(ruleDecl, otherRuleDecl, rm.rules.indexOf(ruleDecl))
					getEnumEditConflicts(ruleDecl, otherRuleDecl, rm.rules.indexOf(ruleDecl))
				}
			}
		}
	}

	def getDeleteConflicts(RuleDeclaration a, RuleDeclaration b, int index) {

		val aRules = a.eAllContents.toList.filter(RemoveSchema)
		val bRules = b.eAllContents.toList.filter(RemoveSchema)

//		val maxSize = if(aRules.length >= bRules.length) aRules.length else bRules.length
		for (var i = 0; i < aRules.length; i++) {

			val aSchemaName = aRules.get(i).schema.name
			val aSchemaContainer = aRules.get(i).schema.eContainer as TypeDef
			val aProtocolName = (aSchemaContainer.eContainer as AvroIDLFile).name

			for (var j = 0; j < bRules.length; j++) {

				val bSchemaName = bRules.get(j).schema.name
				val bSchemaContainer = bRules.get(j).schema.eContainer as TypeDef
				val bProtocolName = (bSchemaContainer.eContainer as AvroIDLFile).name

				if (aSchemaName.equals(bSchemaName) && aProtocolName.equals(bProtocolName)) {
					error(
						String.format("CONCURENT MODIFICATION ERROR: %s is deleted in %s and %s",
							aProtocolName + '.' + aSchemaName, a.name, b.name),
						AeditPackage.Literals.RULE_MAP__RULES,
						index
					)
				}
			}

		}

	}

	def getSchemaEditConflicts(RuleDeclaration a, RuleDeclaration b, int index) {

		val aRules = a.eAllContents.toList.filter(ChangeSchema)
		val bRules = b.eAllContents.toList.filter(ChangeSchema)

//		val maxSize = if(aRules.length >= bRules.length) aRules.length else bRules.length
		currentRuleIndex = index

		for (var i = 0; i < aRules.length; i++) {

			val aSchemaName = aRules.get(i).schema.name
			val aSchemaContainer = aRules.get(i).schema.eContainer as TypeDef
			val aProtocolName = (aSchemaContainer.eContainer as AvroIDLFile).name

			for (var j = 0; j < bRules.length; j++) {

				val bSchemaName = bRules.get(j).schema.name
				val bSchemaContainer = bRules.get(j).schema.eContainer as TypeDef
				val bProtocolName = (bSchemaContainer.eContainer as AvroIDLFile).name

				if (aSchemaName.equals(bSchemaName) && aProtocolName.equals(bProtocolName)) {
					warning(
						String.format("CONCURENT MODIFICATION ERROR: %s is edited in %s and %s",
							aProtocolName + '.' + aSchemaName, a.name, b.name),
						AeditPackage.Literals.RULE_MAP__RULES,
						index
					)

					getVarDeleteConflicts(aRules.get(i), bRules.get(j), a.name, b.name)
					getVarRenameConflicts(aRules.get(i), bRules.get(j), a.name, b.name)
					getVarSetTypeConflicts(aRules.get(i), bRules.get(j), a.name, b.name)
					getVarChangeDataConflicts(aRules.get(i), bRules.get(j), a.name, b.name)
				}
			}

		}

	}

	int currentRuleIndex;

	def getEnumEditConflicts(RuleDeclaration a, RuleDeclaration b, int index) {
		val aRules = a.eAllContents.toList.filter(ChangeEnum)
		val bRules = b.eAllContents.toList.filter(ChangeEnum)

//		val maxSize = if(aRules.length >= bRules.length) aRules.length else bRules.length
		currentRuleIndex = index

		for (var i = 0; i < aRules.length; i++) {

			val aSchemaName = aRules.get(i).schema.name
			val aSchemaContainer = aRules.get(i).schema.eContainer as TypeDef
			val aProtocolName = (aSchemaContainer.eContainer as AvroIDLFile).name

			for (var j = 0; j < bRules.length; j++) {

				val bSchemaName = bRules.get(j).schema.name
				val bSchemaContainer = bRules.get(j).schema.eContainer as TypeDef
				val bProtocolName = (bSchemaContainer.eContainer as AvroIDLFile).name

				if (aSchemaName.equals(bSchemaName) && aProtocolName.equals(bProtocolName)) {
					warning(
						String.format("CONCURENT MODIFICATION ERROR: %s is edited in %s and %s",
							aProtocolName + '.' + aSchemaName, a.name, b.name),
						AeditPackage.Literals.RULE_MAP__RULES,
						index
					)

					getVarDeleteConflicts(aRules.get(i), bRules.get(j), a.name, b.name)
					getVarRenameConflicts(aRules.get(i), bRules.get(j), a.name, b.name)

				}
			}

		}
	}

	def getVariable(String currentProtocol, String currentSchema, String fieldName) {
		var field = protocols.get(currentProtocol).eAllContents.filter(Field).filter [
			it.name.equals(fieldName)
		].toList

		return field.filter[(it.eContainer as RecordType).name.equals(currentSchema)].toList.get(0)
	}

	def isUnique(String fullName) {
		if (newVariables.contains(fullName) || existingVariables.contains(fullName)) {
			if (removedVariables.contains(fullName)) {
				return false
			}
			return true
		}
		return false
	}

	def getVarDeleteConflicts(GenericRule a, GenericRule b, String aName, String bName) {

		if (a instanceof ChangeEnum && b instanceof ChangeEnum) {

			checkConcurrentEnumDelete(a.eAllContents.toIterable.filter(RemoveEnum),
				b.eAllContents.toIterable.filter(RemoveEnum), aName, bName)

		} else if (a instanceof ChangeSchema && b instanceof ChangeSchema) {

			checkConcurrentVarDelete(a.eAllContents.toIterable.filter(RemoveVariable),
				b.eAllContents.toIterable.filter(RemoveVariable), aName, bName)

		}
	}

	def getVarRenameConflicts(GenericRule a, GenericRule b, String aName, String bName) {

		if (a instanceof ChangeEnum && b instanceof ChangeEnum) {

			checkConcurrentEnumRename(a.eAllContents.toIterable.filter(RenameEnum),
				b.eAllContents.toIterable.filter(RenameEnum), aName, bName)

		} else if (a instanceof ChangeSchema && b instanceof ChangeSchema) {

			checkConcurrentVarRename(a.eAllContents.toIterable.filter(RenameVariable),
				b.eAllContents.toIterable.filter(RenameVariable), aName, bName)

		}

	}

	def getVarSetTypeConflicts(GenericRule a, GenericRule b, String aName, String bName) {

		if (a instanceof ChangeSchema && b instanceof ChangeSchema) {

			checkConcurrentVarTypeChange(a.eAllContents.toIterable.filter(ChangeType),
				b.eAllContents.toIterable.filter(ChangeType), aName, bName)

		}

	}

	def getVarChangeDataConflicts(GenericRule a, GenericRule b, String aName, String bName) {

		if (a instanceof ChangeSchema && b instanceof ChangeSchema) {

			checkConcurrentVarValueChange(a.eAllContents.toIterable.filter(ChangeDefValue),
				b.eAllContents.toIterable.filter(ChangeDefValue), aName, bName)

		}

	}

	// Helper methods
	def checkConcurrentEnumDelete(Iterable<RemoveEnum> alist, Iterable<RemoveEnum> blist, String aRuleName,
		String bRuleName) {

		var List<String> deletedEnumsA = new ArrayList<String>();
		var List<String> deletedEnumsB = new ArrayList<String>();

		for (removeEnumRule : alist) {
			deletedEnumsA.add(removeEnumRule.varName)
		}

		for (removeEnumRule : blist) {
			deletedEnumsB.add(removeEnumRule.varName)
		}

		displayVarErrors(deletedEnumsA, deletedEnumsB, aRuleName, bRuleName, "deleted")

	}

	def checkConcurrentVarDelete(Iterable<RemoveVariable> alist, Iterable<RemoveVariable> blist, String aRuleName,
		String bRuleName) {

		var List<String> deletedVarsA = new ArrayList<String>();
		var List<String> deletedVarsB = new ArrayList<String>();

		for (removeVarRule : alist) {
			deletedVarsA.add(removeVarRule.variable.name)
		}

		for (removeVarRule : blist) {
			deletedVarsB.add(removeVarRule.variable.name)
		}

		displayVarErrors(deletedVarsA, deletedVarsB, aRuleName, bRuleName, "deleted")

	}

	def checkConcurrentEnumRename(Iterable<RenameEnum> alist, Iterable<RenameEnum> blist, String aRuleName,
		String bRuleName) {
		var List<String> renamedVarsA = new ArrayList<String>();
		var List<String> renamedVarsB = new ArrayList<String>();

		for (renameEnumRule : alist) {
			renamedVarsA.add(renameEnumRule.oldName)
		}

		for (renameEnumRule : blist) {
			renamedVarsB.add(renameEnumRule.oldName)
		}

		displayVarErrors(renamedVarsA, renamedVarsB, aRuleName, bRuleName, "renamed")
	}

	def checkConcurrentVarRename(Iterable<RenameVariable> alist, Iterable<RenameVariable> blist, String aRuleName,
		String bRuleName) {
		var List<String> renamedVarsA = new ArrayList<String>();
		var List<String> renamedVarsB = new ArrayList<String>();

		for (renameVarRule : alist) {
			renamedVarsA.add(renameVarRule.variable.name)
		}

		for (renameVarRule : blist) {
			renamedVarsB.add(renameVarRule.variable.name)
		}

		displayVarErrors(renamedVarsA, renamedVarsB, aRuleName, bRuleName, "renamed")
	}

	def checkConcurrentVarTypeChange(Iterable<ChangeType> alist, Iterable<ChangeType> blist, String aRuleName,
		String bRuleName) {

		var List<String> changedVarsA = new ArrayList<String>();
		var List<String> changedVarsB = new ArrayList<String>();

		for (changeTypeRule : alist) {
			changedVarsA.add(changeTypeRule.field.name)
		}

		for (changeTypeRule : blist) {
			changedVarsB.add(changeTypeRule.field.name)
		}

		displayVarErrors(changedVarsA, changedVarsB, aRuleName, bRuleName, "modified (set_type)")

	}

	def checkConcurrentVarValueChange(Iterable<ChangeDefValue> alist, Iterable<ChangeDefValue> blist, String aRuleName,
		String bRuleName) {

		var List<String> changedVarsA = new ArrayList<String>();
		var List<String> changedVarsB = new ArrayList<String>();

		for (changeValRule : alist) {
			changedVarsA.add(changeValRule.field.name)
		}

		for (changeValRule : blist) {
			changedVarsB.add(changeValRule.field.name)
		}

		displayVarErrors(changedVarsA, changedVarsB, aRuleName, bRuleName, "modified (set_val)")

	}

	def displayVarErrors(List<String> listA, List<String> listB, String aRuleName, String bRuleName,
		String errMessage) {

		if (listA.length >= listB.length) {
			listA.retainAll(listB)
			for (varName : listA) {
				error(
					String.format("CONCURRENT MODIFICATION ERROR: %s is %s in %s and %s", varName, errMessage,
						aRuleName, bRuleName), AeditPackage.Literals.RULE_MAP__RULES, currentRuleIndex)
			}
		} else {
			listB.retainAll(listA)
			for (varName : listB) {
				error(
					String.format("CONCURRENT MODIFICATION ERROR: %s is %s in %s and %s", varName, errMessage,
						aRuleName, bRuleName), AeditPackage.Literals.RULE_MAP__RULES, currentRuleIndex)
			}
		}

	}

	// Array validation
	@Check
	def checkRemoveArrayValue(RemoveArrayValue removeArrayValue) {
		if (!isFieldInSchema(removeArrayValue.variable, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.REMOVE_ARRAY_VALUE__VARIABLE, ErrorCodes.REMOVE_ARRAY_VALUE)) {
			return null
		}

		var fullName = currentProtocol + '.' + currentSchema + '.' + removeArrayValue.variable.name

		// Check if the given reference is an array
		if (!(removeArrayValue.variable.type instanceof ArrayFieldType)) {
			error(ErrorMessages.NOT_ARRAY, AeditPackage.Literals.REMOVE_ARRAY_VALUE__VARIABLE,
				ErrorCodes.REMOVE_ARRAY_VALUE)
			return null
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_FIELD, AeditPackage.Literals.REMOVE_ARRAY_VALUE__VARIABLE,
				ErrorCodes.REMOVE_ARRAY_VALUE)
			return null
		}

		val arraySize = getArraySize(removeArrayValue.variable, fullName)

		if (arraySize == 0) {
			error(ErrorMessages.EMPTY_ARRAY, AeditPackage.Literals.REMOVE_ARRAY_VALUE__VARIABLE,
				ErrorCodes.REMOVE_ARRAY_VALUE)
			return null
		}

		if (!arrayContains(removeArrayValue.variable, removeArrayValue.valueToRemove)) {
			error(ErrorMessages.VALUE_DOES_NOT_EXIST_IN_ARRAY,
				AeditPackage.Literals.REMOVE_ARRAY_VALUE__VALUE_TO_REMOVE, ErrorCodes.REMOVE_ARRAY_VALUE)
			return null
		}

		arraySizes.put(fullName, arraySize - 1)
	}

	@Check
	def checkRemoveArrayValueAtIndex(RemoveArrayValueAtIndex removeArrayValueAtIndex) {

		if (!isFieldInSchema(removeArrayValueAtIndex.array, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.REMOVE_ARRAY_VALUE_AT_INDEX__ARRAY, ErrorCodes.REMOVE_ARRAY_VALUE_AT_INDEX)) {
			return null
		}

		var fullName = currentProtocol + '.' + currentSchema + '.' + removeArrayValueAtIndex.array.name

		// Check if the given reference is an array
		if (!(removeArrayValueAtIndex.array.type instanceof ArrayFieldType)) {
			error(ErrorMessages.NOT_ARRAY, AeditPackage.Literals.REMOVE_ARRAY_VALUE_AT_INDEX__ARRAY,
				ErrorCodes.REMOVE_ARRAY_VALUE_AT_INDEX)
			return null
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_FIELD, AeditPackage.Literals.REMOVE_ARRAY_VALUE_AT_INDEX__ARRAY,
				ErrorCodes.REMOVE_ARRAY_VALUE_AT_INDEX)
			return null
		}

		val arraySize = getArraySize(removeArrayValueAtIndex.array, fullName)
		val index = removeArrayValueAtIndex.index

		if (arraySize == 0) {
			error(ErrorMessages.EMPTY_ARRAY, AeditPackage.Literals.REMOVE_ARRAY_VALUE_AT_INDEX__ARRAY,
				ErrorCodes.REMOVE_ARRAY_VALUE_AT_INDEX)
			return null
		}

		if (index < 0 || index >= arraySize) {
			error(ErrorMessages.INDEX_OUT_OF_RANGE, AeditPackage.Literals.REMOVE_ARRAY_VALUE_AT_INDEX__ARRAY,
				ErrorCodes.REMOVE_ARRAY_VALUE_AT_INDEX)
			return null
		}

		arraySizes.put(fullName, arraySize - 1)

	}

	@Check
	def checkAddValueToArray(AddValueToArray addValueToArray) {

		if (!isFieldInSchema(addValueToArray.array, ErrorMessages.FIELD_NOT_IN_SCHEMA,
			AeditPackage.Literals.ADD_VALUE_TO_ARRAY__ARRAY, ErrorCodes.ADD_ARRAY_VALUE)) {
			return null
		}

		var fullName = currentProtocol + '.' + currentSchema + '.' + addValueToArray.array.name

		// Check if the given reference is an array
		if (!(addValueToArray.array.type instanceof ArrayFieldType)) {
			error(ErrorMessages.NOT_ARRAY, AeditPackage.Literals.ADD_VALUE_TO_ARRAY__ARRAY, ErrorCodes.ADD_ARRAY_VALUE)
			return null
		}

		if (removedVariables.contains(fullName)) {
			error(ErrorMessages.DELETED_FIELD, AeditPackage.Literals.ADD_VALUE_TO_ARRAY__ARRAY,
				ErrorCodes.ADD_ARRAY_VALUE, fullName)
			return null
		}

		val arraySize = getArraySize(addValueToArray.array, fullName)
		val index = addValueToArray.index

		if (index < 0 || index > arraySize) {
			error(ErrorMessages.INDEX_OUT_OF_RANGE, AeditPackage.Literals.ADD_VALUE_TO_ARRAY__INDEX,
				ErrorCodes.ADD_ARRAY_VALUE)
			return null
		}

		arraySizes.put(fullName, arraySize + 1)

	}

	// Helper methods
	def isFieldInSchema(Field field, String errorMessage, EStructuralFeature feature, String code) {

		if (field === null) {
			return false
		}

		if (!HelperClass.getFieldQualifiedName(field).equals(currentProtocol + '.' + currentSchema)) {
			error(errorMessage, feature, code)
			return false
		}

		return true

	}

	def getArraySize(Field field, String fullName) {

		if (arraySizes.containsKey(fullName)) {
			return arraySizes.get(fullName)
		}

		if (field.^default !== null) {
			val array = field.^default as Array
			return array.values.value.size
		}

		return 0

	}

	def addEmptyValueToArray(Field field) {

		if (field.^default !== null) {
			val array = field.^default as Array
			array.values.value.add(AvroIDLFactory.eINSTANCE.createStringValue => [^val = "EMPTY_VAL"])
		}

	}

	def arrayContains(Field field, Value value) {

		if (field.^default !== null) {
			val array = field.^default as Array
			for (arrayValue : array.values.value) {
				val realVal = HelperClass.getValue(value)
				if (HelperClass.getValue(arrayValue).equals(realVal)) {
					return true
				}
			}
		}

		return false
	}

}
